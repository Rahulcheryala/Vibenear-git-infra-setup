name: Update Promotion PR on New Commits
run-name: Update staging promotion PR when new commits added to develop

on:
  push:
    branches:
      - develop
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - develop

permissions:
  contents: write
  pull-requests: write

jobs:
  check-and-update-promotion-pr:
    name: Check and Update Promotion PR
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    steps:
      - name: Checkout develop
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check for existing staging promotion PR
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          echo "üîç Checking for existing staging promotion PR..."
          EXISTING_PR="$(gh pr list --base staging --head staging-promoter --state open --json number --jq '.[0].number' || true)"

          if [ -n "${EXISTING_PR:-}" ] && [ "${EXISTING_PR}" != "null" ]; then
            echo "‚úÖ Found existing promotion PR: #$EXISTING_PR"
            echo "pr_exists=true" >> "$GITHUB_OUTPUT"
            echo "pr_number=$EXISTING_PR" >> "$GITHUB_OUTPUT"
          else
            echo "‚ÑπÔ∏è No existing promotion PR found"
            echo "pr_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Update promotion PR with new commits
        if: steps.check_pr.outputs.pr_exists == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.check_pr.outputs.pr_number }}
        run: |
          set -euo pipefail

          echo "üîÑ Updating promotion PR #$PR_NUMBER with new commits..."

          # Fetch staging branch for comparison
          git fetch origin staging:origin-staging

          echo "üîç Finding the last sync point between staging and develop..."
          # Use the same sync point detection logic as staging-promotion.yml
          LAST_SYNC_SHA=""
          for commit in $(git rev-list --merges HEAD | head -200); do
            p1=$(git rev-parse "$commit^1")
            p2=$(git rev-parse "$commit^2" 2>/dev/null || true)
            if git merge-base --is-ancestor "$p1" origin/staging || \
               { [ -n "$p2" ] && git merge-base --is-ancestor "$p2" origin/staging; }; then
              LAST_SYNC_SHA="$commit"
              msg=$(git log -1 --format=%s "$commit")
              echo "‚ÑπÔ∏è Found last staging‚Üídevelop sync at: ${commit:0:9}"
              echo "   Subject: $msg"
              break
            fi
          done

          # If no explicit merge found, use git merge-base as fallback
          if [ -z "$LAST_SYNC_SHA" ]; then
            echo "üîé No staging‚Üídevelop merge commit found"
            echo "   Trying merge-base between develop and staging..."
            if LAST_SYNC_SHA=$(git merge-base origin-staging HEAD 2>/dev/null); then
              echo "‚ÑπÔ∏è Using merge-base as starting point: ${LAST_SYNC_SHA:0:9}"
            else
              echo "‚ö†Ô∏è  No common ancestor found between develop and staging"
              echo "   Using all commits in develop as potentially new"
              LAST_SYNC_SHA=""
            fi
          fi

          # Determine the range to analyze
          if [ -n "$LAST_SYNC_SHA" ]; then
            LOG_RANGE="${LAST_SYNC_SHA}..HEAD"
          else
            # No sync point found - analyze all commits in develop
            LOG_RANGE="HEAD"
          fi

          # Get commits since last sync point
          if [ -n "$LAST_SYNC_SHA" ]; then
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse "$LOG_RANGE" || true)
          else
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse HEAD || true)
          fi

          if [ "${#SHAS_IN_RANGE[@]}" -eq 0 ]; then
            echo "‚úÖ No new commits to add to promotion PR"
            exit 0
          fi

          echo "üìù New commits detected since last sync, updating PR..."

          # Build commits list from SHAs (same format as staging-promotion.yml)
          NEW_COMMITS=""
          for sha in "${SHAS_IN_RANGE[@]}"; do
            subj="$(git log -n1 --format=%s "$sha")"
            NEW_COMMITS+="${sha:0:7} ${subj}"$'\n'
          done
          COMMIT_COUNT="${#SHAS_IN_RANGE[@]}"

          echo "üìä Found $COMMIT_COUNT new commits to add:"
          echo "$NEW_COMMITS"

          IST_TIMESTAMP="$(TZ=Asia/Kolkata date +'%d/%m/%Y %H:%M:%S %Z')"

          # Update PR title and body with new commit count
          CURRENT_TITLE="$(gh pr view $PR_NUMBER --json title --jq '.title')"
          NEW_TITLE="Staging Promotion: $(echo "$CURRENT_TITLE" | sed 's/Staging Promotion: //' | sed 's/ (.*)//')"

          # Build updated PR body
          BODY_FILE=updated_body.md
          {
            echo "## üöÄ Staging Promotion (Updated)"
            echo ""
            echo "This PR promotes features from \`develop\` to \`staging\` for testing."
            echo ""
            echo "### üìã Promotion Information"
            echo "- **Promotion ID**: \`$(echo "$CURRENT_TITLE" | sed -nE 's/.*Promotion: ([^)]+).*/\1/p')\`"
            echo "- **Last Updated**: $IST_TIMESTAMP"
            echo "- **Total Commits**: $COMMIT_COUNT commits (updated)"
            echo "- **Source**: \`develop\`"
            echo "- **Target**: \`staging\`"
            echo "- **Auto-updated**: New commits detected and added"
            echo ""
            echo "### üìù New Commits Added"
            echo '```'
            echo "$NEW_COMMITS"
            echo '```'
            echo ""
            echo "### üîÑ What Happens on Merge"
            echo "1. This PR branch contains one commit per feature group"
            echo "2. Merge with \"Create a merge commit\" or \"Rebase and merge\" to preserve grouped commits"
            echo "3. Staging deployment will be triggered"
            echo "4. Changes will be available for testing in staging environment"
            echo ""
            echo "### ‚úÖ Pre-merge Checklist"
            echo "- [ ] Code review complete"
            echo "- [ ] All tests passing on develop"
            echo "- [ ] No breaking changes without migration plan"
            echo "- [ ] Ready for QA testing"
            echo ""
            echo "---"
            echo "üîç This will deploy to **STAGING** environment for testing."
            echo ""
            echo "üë• Reviewers: @rahulcheryala"
          } > "$BODY_FILE"

          # Update PR title and body
          gh pr edit $PR_NUMBER --title "$NEW_TITLE" --body-file "$BODY_FILE"

          echo "‚úÖ Promotion PR #$PR_NUMBER updated successfully"
          echo "üìä Added $COMMIT_COUNT new commits to the promotion"

      - name: Update promoter branch with new commits
        if: steps.check_pr.outputs.pr_exists == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          echo "üîÑ Updating promoter branch with new commits..."

          # Fetch promoter branch
          git fetch origin staging-promoter:origin-staging-promoter || true

          # Check if promoter branch exists
          if ! git show-ref --verify --quiet refs/remotes/origin/staging-promoter; then
            echo "‚ÑπÔ∏è Promoter branch doesn't exist, skipping update"
            exit 0
          fi

          # Checkout promoter branch
          git checkout -B staging-promoter origin-staging-promoter

          # Configure git for commits
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Use the same sync point detection logic
          echo "üîç Finding the last sync point between staging and develop..."
          LAST_SYNC_SHA=""
          for commit in $(git rev-list --merges develop | head -200); do
            p1=$(git rev-parse "$commit^1")
            p2=$(git rev-parse "$commit^2" 2>/dev/null || true)
            if git merge-base --is-ancestor "$p1" origin/staging || \
               { [ -n "$p2" ] && git merge-base --is-ancestor "$p2" origin/staging; }; then
              LAST_SYNC_SHA="$commit"
              msg=$(git log -1 --format=%s "$commit")
              echo "‚ÑπÔ∏è Found last staging‚Üídevelop sync at: ${commit:0:9}"
              echo "   Subject: $msg"
              break
            fi
          done

          # If no explicit merge found, use git merge-base as fallback
          if [ -z "$LAST_SYNC_SHA" ]; then
            echo "üîé No staging‚Üídevelop merge commit found"
            echo "   Trying merge-base between develop and staging..."
            if LAST_SYNC_SHA=$(git merge-base origin-staging develop 2>/dev/null); then
              echo "‚ÑπÔ∏è Using merge-base as starting point: ${LAST_SYNC_SHA:0:9}"
            else
              echo "‚ö†Ô∏è  No common ancestor found between develop and staging"
              echo "   Using all commits in develop as potentially new"
              LAST_SYNC_SHA=""
            fi
          fi

          # Determine the range to analyze
          if [ -n "$LAST_SYNC_SHA" ]; then
            LOG_RANGE="${LAST_SYNC_SHA}..develop"
          else
            # No sync point found - analyze all commits in develop
            LOG_RANGE="develop"
          fi

          # Get commits since last sync point
          if [ -n "$LAST_SYNC_SHA" ]; then
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse "$LOG_RANGE" || true)
          else
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse develop || true)
          fi

          if [ "${#SHAS_IN_RANGE[@]}" -eq 0 ]; then
            echo "‚ÑπÔ∏è No new commits to add to promoter branch"
            exit 0
          fi

          echo "üìù Adding new commits to promoter branch..."

          # Group new commits by feature (similar to staging-promotion workflow)
          declare -A GROUP_TO_SHAS
          for commit in "${SHAS_IN_RANGE[@]}"; do
            # Get feature branch name from commit
            pr_json="$(gh api -H "Accept: application/vnd.github+json" repos/${GITHUB_REPOSITORY}/commits/${commit}/pulls --jq '.[0] | {url: .html_url, head: .head.ref}' 2>/dev/null || true)"
            group=""
            if [ -n "$pr_json" ]; then
              group="$(printf '%s' "$pr_json" | jq -r '.head // empty')"
            fi
            if [[ -z "$group" || ! "$group" =~ ^feature/ ]]; then
              group="misc/ungrouped"
            fi

            if [ -n "${GROUP_TO_SHAS[$group]:-}" ]; then
              GROUP_TO_SHAS[$group]="${GROUP_TO_SHAS[$group]} $commit"
            else
              GROUP_TO_SHAS[$group]="$commit"
            fi
          done

          # Apply new commits to promoter branch
          for group in "${!GROUP_TO_SHAS[@]}"; do
            shas="${GROUP_TO_SHAS[$group]}"
            echo "  ‚Ä¢ Adding group: $group"
            echo "    SHAs: $shas"

            # Reset any previous cherry-pick state
            git cherry-pick --abort 2>/dev/null || true
            git reset --hard HEAD
            git clean -fd

            # Cherry-pick commits without committing
            if git cherry-pick -n $shas; then
              if ! git diff --cached --quiet; then
                git commit -m "$group"
                echo "    ‚úÖ Added updated commit for $group"
              else
                echo "    ‚ÑπÔ∏è No changes for $group"
              fi
            else
              echo "    ‚ö†Ô∏è Cherry-pick failed for $group - attempting conflict resolution"

              # Check if there are conflicts
              if git status --porcelain | grep -q "^UU\|^AA\|^DD"; then
                echo "    üîß Resolving conflicts for $group..."

                # Try to resolve conflicts automatically
                # For modify/delete conflicts, prefer the modified version
                git status --porcelain | while read status file; do
                  if [[ "$status" =~ ^UU|^AA|^DD ]]; then
                    echo "      Resolving conflict in: $file"
                    if [[ "$status" =~ ^DD ]]; then
                      # Delete/Delete conflict - remove the file
                      git rm "$file" 2>/dev/null || true
                    elif [[ "$status" =~ ^UU|^AA ]]; then
                      # Modify/Modify or Add/Add conflict - add the file
                      git add "$file" 2>/dev/null || true
                    fi
                  fi
                done

                # Check if conflicts are resolved
                if ! git status --porcelain | grep -q "^UU\|^AA\|^DD"; then
                  if ! git diff --cached --quiet; then
                    git commit -m "$group"
                    echo "    ‚úÖ Added updated commit for $group (conflicts resolved)"
                  else
                    echo "    ‚ÑπÔ∏è No changes for $group after conflict resolution"
                  fi
                else
                  echo "    ‚ùå Could not resolve conflicts for $group - skipping"
                  git cherry-pick --abort 2>/dev/null || true
                fi
              else
                echo "    ‚ùå Cherry-pick failed for $group - skipping"
                git cherry-pick --abort 2>/dev/null || true
              fi
            fi
          done

          # Push updated promoter branch
          git push origin staging-promoter --force

          echo "‚úÖ Promoter branch updated with new commits"
