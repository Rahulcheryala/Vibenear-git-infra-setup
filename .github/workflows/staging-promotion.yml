name: Staging Promotion
run-name: PR from develop to staging by @${{ github.actor }}

on:
  workflow_dispatch:
    inputs:
      create_pr:
        description: "Create PR from develop to staging"
        required: true
        default: true
        type: boolean

permissions:
  contents: write
  pull-requests: write

jobs:
  # Job 1: Analyze Develop Commits
  commit-analysis:
    name: Commit Analysis
    runs-on: ubuntu-latest
    outputs:
      promotion_needed: ${{ steps.analyze.outputs.promotion_needed }}
      commit_count: ${{ steps.analyze.outputs.commit_count }}
      promotion_id: ${{ steps.analyze.outputs.promotion_id }}
      timestamp: ${{ steps.analyze.outputs.timestamp }}
      new_commits: ${{ steps.analyze.outputs.new_commits }}
      existing_pr: ${{ steps.analyze.outputs.existing_pr }}
      groups: ${{ steps.analyze.outputs.groups }}
      grouped_commits_md: ${{ steps.analyze.outputs.grouped_commits_md }}
      feature_prs_md: ${{ steps.analyze.outputs.feature_prs_md }}

    steps:
      - name: Checkout develop
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch staging branch
        run: |
          echo "üì• Fetching staging branch for comparison..."
          git fetch origin staging:origin-staging
          echo "‚úÖ Staging branch fetched successfully"

      - name: Analyze develop commits for staging promotion
        id: analyze
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          echo "üì• Ensuring origin/staging is up to date..."
          git fetch origin staging:origin-staging

          echo "üîç Quick tree diff (develop vs staging)..."
          if git diff --quiet origin-staging..HEAD; then
            echo "‚úÖ Develop and staging have identical content"
            {
              echo "promotion_needed=false"
              echo "commit_count=0"
              echo "promotion_id="
              echo "timestamp=$(date +'%d/%m/%Y %H:%M:%S UTC')"
              echo "existing_pr="
              echo "new_commits="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "üìù Getting commits to promote (develop -> staging)..."
          echo ""

          echo "üîç Find the last point where staging was merged back into develop..."
          # Look for merge commits in develop where staging was brought in
          # These commits mark synchronization points after a promotion
          LAST_SYNC_SHA=""
          for commit in $(git log HEAD --merges --format=%H | head -50); do
            # Check if commit message indicates staging was merged into develop
            msg=$(git log -1 --format=%s "$commit")
            if echo "$msg" | grep -qi "merge.*staging"; then
              LAST_SYNC_SHA="$commit"
              echo "‚ÑπÔ∏è Found last staging‚Üídevelop sync at: ${commit:0:9}"
              echo "   Commit: $msg"
              break
            fi
          done
          echo ""

          # If no explicit merge found, use git merge-base as fallback
          if [ -z "$LAST_SYNC_SHA" ]; then
            echo "üîé No staging‚Üídevelop merge commit found"
            echo "   Trying merge-base between develop and staging..."
            if LAST_SYNC_SHA=$(git merge-base origin-staging HEAD 2>/dev/null); then
              echo "‚ÑπÔ∏è Using merge-base as starting point: ${LAST_SYNC_SHA:0:9}"
            else
              echo "‚ö†Ô∏è  No common ancestor found between develop and staging"
              echo "   This may happen if history was rewritten or is a shallow clone"
              echo "   Using all commits in develop as potentially new"
              LAST_SYNC_SHA=""
            fi
          fi

          # Determine the range to analyze
          if [ -n "$LAST_SYNC_SHA" ]; then
            LOG_RANGE="${LAST_SYNC_SHA}..HEAD"
          else
            # No sync point found - analyze all commits in develop
            LOG_RANGE="HEAD"
          fi

          echo "üìù Analyzing commits in range: $LOG_RANGE"

          # Get all commits to analyze (oldest first)
          if [ -n "$LAST_SYNC_SHA" ]; then
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse "$LOG_RANGE" || true)
          else
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse HEAD || true)
          fi

          if [ "${#SHAS_IN_RANGE[@]}" -eq 0 ]; then
            echo "‚ÑπÔ∏è No commits found since last sync with staging"
            {
              echo "promotion_needed=false"
              echo "commit_count=0"
              echo "promotion_id="
              echo "timestamp=$(date +'%d/%m/%Y %H:%M:%S UTC')"
              echo "existing_pr="
              echo "new_commits="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Build commits list for PR body from SHAs
          NEW_COMMITS=""
          for sha in "${SHAS_IN_RANGE[@]}"; do
            subj="$(git log -n1 --format=%s "$sha")"
            NEW_COMMITS+="${sha:0:7} ${subj}"$'\n'
          done

          echo "üîé Check if an open develop‚Üístaging PR exists..."
          EXISTING_PR="$(gh pr list --base staging --head develop --state open --json number --jq '.[0].number' || true)"
          EXISTING_ID=""
          if [ -n "${EXISTING_PR:-}" ] && [ "${EXISTING_PR}" != "null" ]; then
            echo "‚ÑπÔ∏è Open PR detected: #$EXISTING_PR"
            PR_TEXT="$(gh pr view "$EXISTING_PR" --json title,body --jq '[.title,.body]|join("\n")' || true)"
            # Extract existing Promotion ID if present
            EXISTING_ID="$(printf "%s" "$PR_TEXT" | sed -nE 's/.*Promotion ID[^`]*`([^`]+)`.*/\1/p' | head -n1 || true)"
          fi

          TIMESTAMP="$(date +'%d/%m/%Y %H:%M:%S UTC')"
          if [ -n "${EXISTING_ID:-}" ]; then
            PROMOTION_ID="$EXISTING_ID"
            echo "üîÅ Reusing existing PR promotion ID: $PROMOTION_ID"
          else
            PROMOTION_ID="staging_$(date +'%d-%m-%Y_%H.%M.%S')"
            echo "üÜï Generated new promotion ID: $PROMOTION_ID"
          fi

          COMMIT_COUNT="${#SHAS_IN_RANGE[@]}"

          # Group by feature head ref using GitHub API (first associated PR)
          declare -A GROUP_TO_SHAS
          declare -A GROUP_TO_PR

          for sha in "${SHAS_IN_RANGE[@]}"; do
            pr_json="$(gh api -H "Accept: application/vnd.github+json" repos/${GITHUB_REPOSITORY}/commits/${sha}/pulls --jq '.[0] | {url: .html_url, head: .head.ref}' 2>/dev/null || true)"
            group=""
            pr_url=""
            if [ -n "$pr_json" ]; then
              group="$(printf '%s' "$pr_json" | jq -r '.head // empty')"
              pr_url="$(printf '%s' "$pr_json" | jq -r '.url // empty')"
            fi
            if [[ -z "$group" || ! "$group" =~ ^feature/ ]]; then
              group="misc/ungrouped"
            fi
            if [ -n "${GROUP_TO_SHAS[$group]:-}" ]; then
              GROUP_TO_SHAS[$group]="${GROUP_TO_SHAS[$group]} $sha"
            else
              GROUP_TO_SHAS[$group]="$sha"
            fi
            if [ -n "$pr_url" ] && [ -z "${GROUP_TO_PR[$group]:-}" ]; then
              GROUP_TO_PR[$group]="$pr_url"
            fi
          done

          GROUPED_MD=$'### üß© Commits Grouped by Feature\n\n'
          FEATURE_PRS_MD=$'### üîó Feature PRs\n\n'
          GROUPS_LINES=""

          mapfile -t GROUP_NAMES < <(printf '%s\n' "${!GROUP_TO_SHAS[@]}" | sort)
          for group in "${GROUP_NAMES[@]}"; do
            shas_line="${GROUP_TO_SHAS[$group]}"
            GROUPS_LINES+="$group|$shas_line"$'\n'
            GROUPED_MD+="#### $group"$'\n'
            pr_link="${GROUP_TO_PR[$group]:-}"
            if [ -n "$pr_link" ]; then
              FEATURE_PRS_MD+="- $group: $pr_link"$'\n'
              GROUPED_MD+="PR: $pr_link"$'\n'
            fi
            for s in $shas_line; do
              subj="$(git log -n1 --format=%s "$s")"
              GROUPED_MD+="- ${s:0:7} ${subj}"$'\n'
            done
            GROUPED_MD+=$'\n'
          done

          echo "üìä Analysis Results:"
          echo "  ‚Ä¢ Commits to promote: $COMMIT_COUNT"
          echo "  ‚Ä¢ Promotion ID: $PROMOTION_ID"
          echo "  ‚Ä¢ Timestamp: $TIMESTAMP"
          echo ""
          echo "üìù Commits to be promoted to staging (grouped):"
          printf "%s\n" "$GROUPED_MD"
          echo ""

          {
            echo "promotion_needed=true"
            echo "commit_count=$COMMIT_COUNT"
            echo "promotion_id=$PROMOTION_ID"
            echo "timestamp=$TIMESTAMP"
            echo "existing_pr=${EXISTING_PR:-}"
          } >> "$GITHUB_OUTPUT"
          {
            echo "new_commits<<EOF"
            printf "%s\n" "$NEW_COMMITS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "groups<<EOF"
            printf "%s\n" "$GROUPS_LINES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "grouped_commits_md<<EOF"
            printf "%s\n" "$GROUPED_MD"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "feature_prs_md<<EOF"
            printf "%s\n" "$FEATURE_PRS_MD"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  # Job 2: Create Staging Promotion PR
  create-pr:
    name: Create Staging PR
    runs-on: ubuntu-latest
    needs: commit-analysis
    if: needs.commit-analysis.outputs.promotion_needed == 'true' && inputs.create_pr
    outputs:
      pr_number: ${{ steps.create_pr.outputs.pr_number }}
      pr_url: ${{ steps.create_pr.outputs.pr_url }}

    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Ensure full fetch (including develop)
        run: |
          git fetch --all --prune
          git fetch origin develop:origin-develop --prune

      - name: Build temp release branch with grouped squash commits
        id: build_temp_branch
        run: |
          set -euo pipefail

          PROMOTION_ID="${{ needs.commit-analysis.outputs.promotion_id }}"
          TEMP_BRANCH="staging-promotion/${PROMOTION_ID}"

          echo "üì¶ Creating temp branch from staging: $TEMP_BRANCH"
          git checkout -B "$TEMP_BRANCH" origin/staging

          echo "üë§ Configuring git author for commits"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          echo "üîÄ Applying grouped cherry-picks as squash commits"
          GROUPS_DATA='${{ needs.commit-analysis.outputs.groups }}'
          echo "$GROUPS_DATA" | while IFS='|' read -r group shas; do
            [ -z "$group" ] && continue
            [ -z "$shas" ] && continue
            echo "  ‚Ä¢ Group: $group"
            echo "    SHAs: $shas"
            git cherry-pick -n $shas
            git commit -m "$group"
          done

          echo "üöÄ Pushing temp branch"
          git push -u origin "$TEMP_BRANCH" --force

          echo "temp_branch=$TEMP_BRANCH" >> "$GITHUB_OUTPUT"

      - name: Create or reuse PR from temp branch to staging
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          REPO="${GITHUB_REPOSITORY}"

          TITLE="Staging Promotion: ${{ needs.commit-analysis.outputs.promotion_id }}"

          BODY_CONTENT="## üöÄ Staging Promotion

          This PR promotes features from \`develop\` to \`staging\` for testing.

          ### üìã Promotion Information
          - **Promotion ID**: \`${{ needs.commit-analysis.outputs.promotion_id }}\`
          - **Timestamp**: ${{ needs.commit-analysis.outputs.timestamp }}
          - **Commit Count**: ${{ needs.commit-analysis.outputs.commit_count }} commits
          - **Source**: \`develop\`
          - **Target**: \`staging\`
          - **Triggered By**: @${{ github.actor }} via manual workflow dispatch

          ### üîó Feature PRs
          ${{ needs.commit-analysis.outputs.feature_prs_md }}

          ### üìù Commits to be Deployed
          ${{ needs.commit-analysis.outputs.grouped_commits_md }}

          ### üîÑ What Happens on Merge
          1. This PR branch contains one commit per feature group
          2. Merge with "Create a merge commit" or "Rebase and merge" to preserve grouped commits
          3. Staging deployment will be triggered
          4. Changes will be available for testing in staging environment

          ### ‚úÖ Pre-merge Checklist
          - [ ] Code review complete
          - [ ] All tests passing on develop
          - [ ] No breaking changes without migration plan
          - [ ] Ready for QA testing

          ---
          üîç This will deploy to **STAGING** environment for testing.

          üë• Reviewers: @rahulcheryala"

          echo "üìù Ensuring PR base=staging head=${{ steps.build_temp_branch.outputs.temp_branch }}"

          echo "üîé Checking for existing open PR from temp branch ‚Üí staging..."
          EXISTING_NUMBER="$(gh pr list --base staging --head "${{ steps.build_temp_branch.outputs.temp_branch }}" --state open --json number --jq '.[0].number' || true)"
          if [ -n "${EXISTING_NUMBER:-}" ] && [ "${EXISTING_NUMBER}" != "null" ]; then
            PR_NUMBER="$EXISTING_NUMBER"
            echo "üîÅ Reusing PR #$PR_NUMBER and updating title/body..."
            gh api -X PATCH "repos/${REPO}/pulls/${PR_NUMBER}" -f title="$TITLE" -f body="$BODY_CONTENT" >/dev/null
          else
            echo "üÜï Creating PR base=staging head=${{ steps.build_temp_branch.outputs.temp_branch }}..."
            PR_NUMBER="$(gh api -X POST "repos/${REPO}/pulls" \
              -f title="$TITLE" \
              -f head="${{ steps.build_temp_branch.outputs.temp_branch }}" \
              -f base="staging" \
              -f body="$BODY_CONTENT" \
              --jq .number)"
          fi

          PR_URL="$(gh api "repos/${REPO}/pulls/${PR_NUMBER}" --jq .html_url)"

          echo "üè∑Ô∏è Adding labels and requesting reviewers..."
          printf '{"labels":["staging","deployment","promotion","auto-generated"]}\n' > labels.json
          gh api -X POST "repos/${REPO}/issues/${PR_NUMBER}/labels" --input labels.json >/dev/null || true
          printf '{"reviewers":["rahulcheryala"]}\n' > reviewers.json
          gh api -X POST "repos/${REPO}/pulls/${PR_NUMBER}/requested_reviewers" --input reviewers.json >/dev/null || true

          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "üîó PR Link: $PR_URL"

  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [commit-analysis, create-pr]
    if: always() && needs.commit-analysis.outputs.promotion_needed == 'true'
    steps:
      - name: Display workflow summary
        run: |
          echo ""
          echo "================================================"
          echo "üöÄ STAGING PROMOTION WORKFLOW COMPLETED"
          echo "================================================"
          echo ""
          echo "‚úÖ Analysis complete"
          if [ "${{ needs.create-pr.result }}" = "success" ]; then
            echo "‚úÖ PR created/updated"
          else
            echo "‚ö†Ô∏è PR not created (skipped or failed)"
          fi
          echo ""
          echo "üìã Promotion Details:"
          echo "  ‚Ä¢ Promotion ID: ${{ needs.commit-analysis.outputs.promotion_id }}"
          echo "  ‚Ä¢ Timestamp: ${{ needs.commit-analysis.outputs.timestamp }}"
          echo "  ‚Ä¢ Commit Count: ${{ needs.commit-analysis.outputs.commit_count }}"
          echo "  ‚Ä¢ PR Number: ${{ needs.create-pr.outputs.pr_number }}"
          echo ""
          echo "üîó PR Link: ${{ needs.create-pr.outputs.pr_url }}"
          echo "üß™ Reminder: Merging deploys to STAGING for testing."
          echo ""
