name: Production Release
run-name: Production Release by @${{ github.actor }}

on:
  workflow_dispatch:
    inputs:
      create_pr:
        description: "Create PR from staging to main for production deployment"
        required: true
        default: true
        type: boolean
      release_notes:
        description: "Release notes for prod deployment"
        required: false
        default: ""
        type: string

description: |
  Manually triggered workflow to create or update a Pull Request from `staging` to `main`
  for production deployment.
  
  **How Commit Analysis Works:**
  - Finds the last point where `main` was merged back into `staging` (synchronization point)
  - Analyzes commits added to `staging` after that sync point
  - Filters commits to ensure content isn't already in `main` (handles squash merges correctly)
  - Tags are used for release identification, not for commit range calculation
  
  **Important:** After merging a staging‚Üímain PR, always merge `main` back into `staging` to 
  mark the synchronization point. This prevents already-merged commits from appearing in future 
  promotion analyses.
  
  The actual release tag is pushed only after the PR is squash-merged to main by a separate workflow.

permissions:
  contents: write
  pull-requests: write

jobs:
  # Job 1: Analyze Staging Commits
  commit-analysis:
    name: Commit Analysis
    runs-on: ubuntu-latest
    outputs:
      promotion_needed: ${{ steps.analyze.outputs.promotion_needed }}
      commit_count: ${{ steps.analyze.outputs.commit_count }}
      release_tag: ${{ steps.analyze.outputs.release_tag }}
      timestamp: ${{ steps.analyze.outputs.timestamp }}
      new_commits: ${{ steps.analyze.outputs.new_commits }}
      existing_pr: ${{ steps.analyze.outputs.existing_pr }}

    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch main branch and tags
        run: |
          echo "üì• Fetching main branch for comparison..."
          git fetch origin main:origin-main --tags
          echo "‚úÖ Main branch fetched successfully"

      - name: Analyze staging commits for production promotion
        id: analyze
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          echo "üì• Fetching main and tags..."
          git fetch origin main:origin-main --tags

          echo "üîç Quick tree diff (staging vs main)..."
          if git diff --quiet origin-main..HEAD; then
            echo "‚úÖ Staging and main have identical content"
            {
              echo "promotion_needed=false"
              echo "commit_count=0"
              echo "release_tag="
              echo "timestamp=$(date +'%d/%m/%Y %H:%M:%S UTC')"
              echo "existing_pr="
              echo "new_commits="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "üîé Find the last point where main was merged back into staging..."
          # Look for merge commits in staging where main was brought in
          # These commits mark synchronization points after a promotion
          LAST_SYNC_SHA=""
          for commit in $(git log HEAD --merges --format=%H | head -50); do
            # Check if commit message indicates main was merged into staging
            msg=$(git log -1 --format=%s "$commit")
            if echo "$msg" | grep -qi "merge.*main"; then
              LAST_SYNC_SHA="$commit"
              echo "‚ÑπÔ∏è Found last main‚Üístaging sync at: ${commit:0:9}"
              echo "   Commit: $msg"
              break
            fi
          done

          # If no explicit merge found, use git merge-base as fallback
          if [ -z "$LAST_SYNC_SHA" ]; then
            echo "üîé No main‚Üístaging merge commit found"
            echo "   Trying merge-base between staging and main..."
            if LAST_SYNC_SHA=$(git merge-base origin-main HEAD 2>/dev/null); then
              echo "‚ÑπÔ∏è Using merge-base as starting point: ${LAST_SYNC_SHA:0:9}"
            else
              echo "‚ö†Ô∏è  No common ancestor found between staging and main"
              echo "   This may happen if main was rewritten or is a shallow clone"
              echo "   Using all commits in staging as potentially new"
              LAST_SYNC_SHA=""
            fi
          fi

          # Determine the range to analyze
          if [ -n "$LAST_SYNC_SHA" ]; then
            LOG_RANGE="${LAST_SYNC_SHA}..HEAD"
          else
            # No sync point found - analyze all commits in staging
            LOG_RANGE="HEAD"
          fi

          echo "üìù Analyzing commits in range: $LOG_RANGE"

          # Get all commits to analyze
          if [ -n "$LAST_SYNC_SHA" ]; then
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse "$LOG_RANGE" || true)
          else
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse HEAD || true)
          fi
          
          if [ "${#SHAS_IN_RANGE[@]}" -eq 0 ]; then
            echo "‚ÑπÔ∏è No commits found since last sync with main"
            {
              echo "promotion_needed=false"
              echo "commit_count=0"
              echo "release_tag="
              echo "timestamp=$(date +'%d/%m/%Y %H:%M:%S UTC')"
              echo "existing_pr="
              echo "new_commits="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "üîç Verifying commits are truly new (not already in main)..."
          # Use git cherry to double-check content isn't already in main
          # This handles edge cases like cherry-picks or content duplication
          mapfile -t CHERRY_PLUS < <(git cherry -v origin-main HEAD | awk '$1=="+"{print $2}' || true)

          # Intersect: only keep commits that are in range AND marked new by cherry
          TMP_RANGE=/tmp/shas_in_range.txt
          TMP_CHERRY=/tmp/cherry_plus.txt
          printf "%s\n" "${SHAS_IN_RANGE[@]}" > "$TMP_RANGE"
          printf "%s\n" "${CHERRY_PLUS[@]}" > "$TMP_CHERRY"

          FILTERED_SHAS=()
          for sha in "${SHAS_IN_RANGE[@]}"; do
            if grep -Fxq "$sha" "$TMP_CHERRY"; then
              FILTERED_SHAS+=("$sha")
            fi
          done

          echo "üß™ Diagnostics:"
          echo "  ‚Ä¢ Commits since last main‚Üístaging sync: ${#SHAS_IN_RANGE[@]}"
          echo "  ‚Ä¢ Commits marked new by git cherry: ${#CHERRY_PLUS[@]}"
          echo "  ‚Ä¢ Final commits to promote: ${#FILTERED_SHAS[@]}"

          if [ "${#FILTERED_SHAS[@]}" -eq 0 ]; then
            echo "‚úÖ No new content to promote (all changes already in main)"
            {
              echo "promotion_needed=false"
              echo "commit_count=0"
              echo "release_tag="
              echo "timestamp=$(date +'%d/%m/%Y %H:%M:%S UTC')"
              echo "existing_pr="
              echo "new_commits="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "üîé Check if an open staging‚Üímain PR exists and try to reuse its tag..."
          EXISTING_PR="$(gh pr list --base main --head staging --state open --json number --jq '.[0].number' || true)"
          EXISTING_TAG=""
          if [ -n "${EXISTING_PR:-}" ] && [ "${EXISTING_PR}" != "null" ]; then
            echo "‚ÑπÔ∏è Open PR detected: #$EXISTING_PR"
            PR_TEXT="$(gh pr view "$EXISTING_PR" --json title,body --jq '[.title,.body]|join(\"\\n\")' || true)"
            # Extract backticked Release Tag value if present
            EXISTING_TAG="$(printf "%s" "$PR_TEXT" | sed -nE 's/.*Release Tag[^`]*`([^`]+)`.*/\1/p' | head -n1 || true)"
          fi

          TIMESTAMP="$(date +'%d/%m/%Y %H:%M:%S UTC')"
          if [ -n "${EXISTING_TAG:-}" ]; then
            RELEASE_TAG="$EXISTING_TAG"
            echo "üîÅ Reusing existing PR release tag: $RELEASE_TAG"
          else
            RELEASE_TAG="release_$(date +'%d-%m-%Y_%H.%M.%S')"
            echo "üÜï Generated new release tag: $RELEASE_TAG"
          fi

          # Build human-readable list for PR body and the SHAs to pick (oldest first preserved)
          NEW_COMMITS=""
          for sha in "${FILTERED_SHAS[@]}"; do
            subj="$(git log -n1 --format=%s "$sha")"
            NEW_COMMITS+=$(printf "%s %s\n" "${sha:0:7}" "$subj")
          done

          COMMIT_COUNT="${#FILTERED_SHAS[@]}"

          echo "üìä Analysis Results:"
          echo "  ‚Ä¢ Commits to promote: $COMMIT_COUNT"
          echo "  ‚Ä¢ Release tag: $RELEASE_TAG"
          echo "  ‚Ä¢ Timestamp: $TIMESTAMP"
          echo ""
          echo "üìù Commits to be promoted to production:"
          printf "%s\n" "$NEW_COMMITS"
          echo ""

          # Outputs
          {
            echo "promotion_needed=true"
            echo "commit_count=$COMMIT_COUNT"
            echo "release_tag=$RELEASE_TAG"
            echo "timestamp=$TIMESTAMP"
            echo "existing_pr=${EXISTING_PR:-}"
          } >> "$GITHUB_OUTPUT"
          {
            echo "new_commits<<EOF"
            printf "%s\n" "$NEW_COMMITS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  # Job 2: Create Production Promotion PR
  create-pr:
    name: Create Production PR
    runs-on: ubuntu-latest
    needs: commit-analysis
    if: needs.commit-analysis.outputs.promotion_needed == 'true' && inputs.create_pr
    outputs:
      pr_number: ${{ steps.create_pr.outputs.pr_number }}
      pr_url: ${{ steps.create_pr.outputs.pr_url }}

    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Ensure full fetch
        run: git fetch --all --prune --tags

      - name: Create or reuse PR from staging to main
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          REPO="${GITHUB_REPOSITORY}"

          TITLE="üöÄ Production Release: ${{ needs.commit-analysis.outputs.release_tag }}"

          BODY_CONTENT="## üöÄ Production Deployment

          This PR promotes the staging environment to production.

          ### üìã Release Information
          - **Release Tag**: \`${{ needs.commit-analysis.outputs.release_tag }}\`
          - **Timestamp**: ${{ needs.commit-analysis.outputs.timestamp }}
          - **Commit Count**: ${{ needs.commit-analysis.outputs.commit_count }} commits
          - **Source**: \`staging\`
          - **Target**: \`main\`
          - **Triggered By**: @${{ github.actor }} via manual workflow dispatch

          ### üìù Features to be Deployed
          \`\`\`text
          ${{ needs.commit-analysis.outputs.new_commits }}
          \`\`\`

          ### üìí Release Notes
          ${{ inputs.release_notes }}

          ### üîÑ What Happens on Merge
          1. Squash merge into a single release commit
          2. Tag \`${{ needs.commit-analysis.outputs.release_tag }}\` will be created (by post-merge workflow)
          3. Production deployment triggered
          4. Clean history: one commit per production release

          ### ‚ö†Ô∏è Important
          - Deploys to **PRODUCTION**
          - Rollback = revert the single release commit
          - Ensure all staging validations are complete

          ### ‚úÖ Pre-deployment Checklist
          - [ ] Staging tests passed
          - [ ] Code review complete
          - [ ] DB migrations verified
          - [ ] Release notes reviewed

          ---
          üîí Requires multiple approvals.

          üë• Reviewers: @rahulcheryala @your-senior-dev"

          echo "üìù Ensuring PR base=main head=staging"

          echo "üîé Checking for existing open PR from staging ‚Üí main..."
          EXISTING_NUMBER="$(gh pr list --base main --head staging --state open --json number --jq '.[0].number' || true)"
          if [ -n "${EXISTING_NUMBER:-}" ] && [ "${EXISTING_NUMBER}" != "null" ]; then
            PR_NUMBER="$EXISTING_NUMBER"
            echo "üîÅ Reusing PR #$PR_NUMBER and updating title/body..."
            gh api -X PATCH "repos/${REPO}/pulls/${PR_NUMBER}" -f title="$TITLE" -f body="$BODY_CONTENT" >/dev/null
          else
            echo "üÜï Creating PR base=main head=staging..."
            PR_NUMBER="$(gh api -X POST "repos/${REPO}/pulls" \
              -f title="$TITLE" \
              -f head="staging" \
              -f base="main" \
              -f body="$BODY_CONTENT" \
              --jq .number)"
          fi

          PR_URL="$(gh api "repos/${REPO}/pulls/${PR_NUMBER}" --jq .html_url)"

          echo "üè∑Ô∏è Adding labels and requesting reviewers..."
          printf '{"labels":["production","deployment","release","auto-generated"]}\n' > labels.json
          gh api -X POST "repos/${REPO}/issues/${PR_NUMBER}/labels" --input labels.json >/dev/null || true
          printf '{"reviewers":["rahulcheryala","your-senior-dev"]}\n' > reviewers.json
          gh api -X POST "repos/${REPO}/pulls/${PR_NUMBER}/requested_reviewers" --input reviewers.json >/dev/null || true

          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "üîó PR Link: $PR_URL"

  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [commit-analysis, create-pr]
    if: always() && needs.commit-analysis.outputs.promotion_needed == 'true'
    steps:
      - name: Display workflow summary
        run: |
          echo ""
          echo "================================================"
          echo "üöÄ PRODUCTION PROMOTION WORKFLOW COMPLETED"
          echo "================================================"
          echo ""
          echo "‚úÖ Analysis complete"
          if [ "${{ needs.create-pr.result }}" = "success" ]; then
            echo "‚úÖ PR created/updated"
          else
            echo "‚ö†Ô∏è PR not created (skipped or failed)"
          fi
          echo ""
          echo "üìã Release Details:"
          echo "  ‚Ä¢ Release Tag: ${{ needs.commit-analysis.outputs.release_tag }}"
          echo "  ‚Ä¢ Timestamp: ${{ needs.commit-analysis.outputs.timestamp }}"
          echo "  ‚Ä¢ Commit Count: ${{ needs.commit-analysis.outputs.commit_count }}"
          echo "  ‚Ä¢ PR Number: ${{ needs.create-pr.outputs.pr_number }}"
          echo ""
          echo "üîó PR Link: ${{ needs.create-pr.outputs.pr_url }}"
          echo "‚ö†Ô∏è Reminder: Merging deploys to PRODUCTION."
          echo ""
