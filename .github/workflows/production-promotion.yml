name: Production Promotion
run-name: PR from staging to main @${{ github.actor }}

on:
  workflow_dispatch:
    inputs:
      create_pr:
        description: "Create PR from staging to main for production deployment"
        required: true
        default: true
        type: boolean
      release_notes:
        description: "Release notes for prod deployment"
        required: false
        default: ""
        type: string

permissions:
  contents: write
  pull-requests: write

jobs:
  # Job 1: Analyze Staging Commits
  commit-analysis:
    name: Commit Analysis
    runs-on: ubuntu-latest
    outputs:
      promotion_needed: ${{ steps.analyze.outputs.promotion_needed }}
      commit_count: ${{ steps.analyze.outputs.commit_count }}
      release_tag: ${{ steps.analyze.outputs.release_tag }}
      timestamp: ${{ steps.analyze.outputs.timestamp }}
      new_commits: ${{ steps.analyze.outputs.new_commits }}
      existing_pr: ${{ steps.analyze.outputs.existing_pr }}
      shas: ${{ steps.analyze.outputs.shas }}
      groups: ${{ steps.analyze.outputs.groups }}
      grouped_commits_md: ${{ steps.analyze.outputs.grouped_commits_md }}
      promotion_prs_md: ${{ steps.analyze.outputs.promotion_prs_md }}

    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch main branch and tags
        run: |
          echo "üì• Fetching main branch for comparison..."
          git fetch origin main:origin-main --tags
          echo "‚úÖ Main branch fetched successfully"

      - name: Analyze staging commits for production promotion
        id: analyze
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          # Use IST (Asia/Kolkata) for all timestamps in this job
          IST_TIMESTAMP="$(TZ=Asia/Kolkata date +'%d/%m/%Y %H:%M:%S %Z')"

          echo "üì• Ensuring origin/main and tags are up to date..."
          git fetch origin main:origin-main --tags
          echo ""

          echo "üîç Find the last point where main was synced back into staging..."
          # Strategy: scan recent commits on staging for empty sync commits with "Sync: main@" pattern
          # These are single-parent empty commits that mark sync points
          LAST_SYNC_SHA=""
          for commit in $(git rev-list HEAD | head -200); do
            # Check if this is an empty commit with sync message pattern
            if git show --format="%s" -s "$commit" | grep -q "^Sync: main@"; then
              # Verify it's an empty commit (no file changes)
              if [ -z "$(git diff-tree --no-commit-id --name-only -r "$commit")" ]; then
                LAST_SYNC_SHA="$commit"
                msg=$(git log -1 --format=%s "$commit")
                echo "‚ÑπÔ∏è Found last main‚Üístaging sync at: ${commit:0:9}"
                echo "   Subject: $msg"
                break
              fi
            fi
          done
          echo ""

          # If no explicit sync commit found, use git merge-base as fallback
          if [ -z "$LAST_SYNC_SHA" ]; then
            echo "üîé No main‚Üístaging sync commit found"
            echo "   Trying merge-base between staging and main..."
            if LAST_SYNC_SHA=$(git merge-base origin-main HEAD 2>/dev/null); then
              echo "‚ÑπÔ∏è Using merge-base as starting point: ${LAST_SYNC_SHA:0:9}"
            else
              echo "‚ö†Ô∏è  No common ancestor found between staging and main"
              echo "   This may happen if main was rewritten or is a shallow clone"
              echo "   Using all commits in staging as potentially new"
              LAST_SYNC_SHA=""
            fi
          fi

          # Determine the range to analyze
          if [ -n "$LAST_SYNC_SHA" ]; then
            LOG_RANGE="${LAST_SYNC_SHA}..HEAD"
          else
            # No sync point found - analyze all commits in staging
            LOG_RANGE="HEAD"
          fi

          echo "üìù Analyzing commits in range: $LOG_RANGE"

          # Get all commits to analyze (oldest first)
          if [ -n "$LAST_SYNC_SHA" ]; then
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse "$LOG_RANGE" || true)
          else
            mapfile -t SHAS_IN_RANGE < <(git rev-list --no-merges --reverse HEAD || true)
          fi

          # Filter out empty sync commits from the analysis
          FILTERED_SHAS=()
          for sha in "${SHAS_IN_RANGE[@]}"; do
            # Skip empty sync commits
            if ! git show --format="%s" -s "$sha" | grep -q "^Sync: main@"; then
              FILTERED_SHAS+=("$sha")
            fi
          done
          SHAS_IN_RANGE=("${FILTERED_SHAS[@]}")

          if [ "${#SHAS_IN_RANGE[@]}" -eq 0 ]; then
            echo "‚ÑπÔ∏è No commits found since last sync with main"
            {
              echo "promotion_needed=false"
              echo "commit_count=0"
              echo "release_tag="
              echo "timestamp=$IST_TIMESTAMP"
              echo "existing_pr="
              echo "new_commits="
            } >> "$GITHUB_OUTPUT"
            exit 0
          fi

          COMMIT_COUNT="${#SHAS_IN_RANGE[@]}"

          # Group by staging promotion (merge commits from staging-promoter to staging)
          declare -A GROUP_TO_SHAS
          declare -A GROUP_TO_PR

          echo "üîç Grouping commits by staging promotion..."

          for sha in "${SHAS_IN_RANGE[@]}"; do
            # Find the staging promotion merge commit that contains this commit
            # Look for merge commits in staging that include this SHA
            group="misc/ungrouped"

            # Search for merge commits in the range that could be staging promotions
            for merge_commit in $(git rev-list --merges "$LOG_RANGE" 2>/dev/null || true); do
              # Check if this SHA is reachable from the merge commit
              if git merge-base --is-ancestor "$sha" "$merge_commit" 2>/dev/null; then
                # Check if this is a staging promotion commit
                merge_msg=$(git log -1 --format=%s "$merge_commit")
                if echo "$merge_msg" | grep -qiE "staging.*promotion"; then
                  group="$merge_commit"
                  # Try to get PR link for this staging promotion
                  pr_json="$(gh api -H "Accept: application/vnd.github+json" repos/${GITHUB_REPOSITORY}/commits/${merge_commit}/pulls --jq '.[0] | {url: .html_url}' 2>/dev/null || true)"
                  if [ -n "$pr_json" ] && [ "$pr_json" != "null" ]; then
                    pr_url="$(printf '%s' "$pr_json" | jq -r '.url // empty')"
                    if [ -n "$pr_url" ] && [ -z "${GROUP_TO_PR[$group]:-}" ]; then
                      GROUP_TO_PR[$group]="$pr_url"
                    fi
                  fi
                  break
                fi
              fi
            done

            if [ -n "${GROUP_TO_SHAS[$group]:-}" ]; then
              GROUP_TO_SHAS[$group]="${GROUP_TO_SHAS[$group]} $sha"
            else
              GROUP_TO_SHAS[$group]="$sha"
            fi
          done
          echo ""

          echo "üîé Check if an open production PR exists and try to reuse its tag..."
          # Prefer the current promoter branch; fall back to legacy head=staging
          EXISTING_PR="$(gh pr list --base main --head production-promoter --state open --json number --jq '.[0].number' || true)"
          if [ -z "${EXISTING_PR:-}" ] || [ "${EXISTING_PR}" = "null" ]; then
            EXISTING_PR="$(gh pr list --base main --head staging --state open --json number --jq '.[0].number' || true)"
          fi
          EXISTING_TAG=""
          if [ -n "${EXISTING_PR:-}" ] && [ "${EXISTING_PR}" != "null" ]; then
            echo "‚ÑπÔ∏è Open PR detected: #$EXISTING_PR"
            PR_TEXT="$(gh pr view "$EXISTING_PR" --json title,body --jq '[.title,.body]|join("\n")' || true)"
            # Extract existing Release Tag value if present (from PR body/title)
            EXISTING_TAG="$(printf "%s" "$PR_TEXT" | sed -nE 's/.*Release Tag[^`]*`([^`]+)`.*/\1/p;s/.*Production Release[^`]*`([^`]+)`.*/\1/p' | head -n1 || true)"
          fi

          TIMESTAMP="$IST_TIMESTAMP"
          if [ -n "${EXISTING_TAG:-}" ]; then
            RELEASE_TAG="$EXISTING_TAG"
            echo "üîÅ Reusing existing PR release tag: $RELEASE_TAG"
          else
            # Generate release tag using IST (Asia/Kolkata)
            RELEASE_TAG="release_$(TZ=Asia/Kolkata date +'%d-%m-%Y_%H.%M.%S')"
            echo "üÜï Generated new release tag (IST): $RELEASE_TAG"
          fi
          echo ""

          # Build markdown fragments without top-level headers
          GROUPED_MD=""
          PROMOTION_PRS_MD=""
          GROUPS_LINES=""

          # Sort groups by the oldest commit date in each group (oldest first)
          declare -A GROUP_TO_OLDEST_DATE
          for group in "${!GROUP_TO_SHAS[@]}"; do
            shas_line="${GROUP_TO_SHAS[$group]}"
            # Get the oldest commit date for this group
            oldest_date=""
            for sha in $shas_line; do
              commit_date=$(git log -1 --format=%ct "$sha" 2>/dev/null || echo "0")
              if [ -z "$oldest_date" ] || [ "$commit_date" -lt "$oldest_date" ]; then
                oldest_date="$commit_date"
              fi
            done
            GROUP_TO_OLDEST_DATE[$group]="$oldest_date"
          done

          # Sort groups by oldest commit date (oldest first)
          mapfile -t GROUP_NAMES < <(
            for group in "${!GROUP_TO_OLDEST_DATE[@]}"; do
              echo "${GROUP_TO_OLDEST_DATE[$group]} $group"
            done | sort -n | cut -d' ' -f2-
          )

          for group in "${GROUP_NAMES[@]}"; do
            shas_line="${GROUP_TO_SHAS[$group]}"
            GROUPS_LINES+="$group|$shas_line"$'\n'

            # Get group title
            if [ "$group" = "misc/ungrouped" ]; then
              GROUPED_MD+="#### misc/ungrouped"$'\n'
            else
              group_title=$(git log -1 --format=%s "$group")
              GROUPED_MD+="#### $group_title"$'\n'
            fi

            pr_link="${GROUP_TO_PR[$group]:-}"
            if [ -n "$pr_link" ]; then
              PROMOTION_PRS_MD+="- $group_title: $pr_link"$'\n'
              GROUPED_MD+="PR: $pr_link"$'\n'
            fi
            for s in $shas_line; do
              subj="$(git log -n1 --format=%s "$s")"
              GROUPED_MD+="- ${s:0:7} ${subj}"$'\n'
            done
            GROUPED_MD+=$'\n'
          done

          # Build human-readable list for PR body
          NEW_COMMITS=""
          for sha in "${SHAS_IN_RANGE[@]}"; do
            subj="$(git log -n1 --format=%s "$sha")"
            NEW_COMMITS+="${sha:0:7} -> ${subj}"$'\n'
          done

          echo "üìä Analysis Results:"
          echo "  ‚Ä¢ Commits to promote: $COMMIT_COUNT"
          echo "  ‚Ä¢ Staging promotions: ${#GROUP_NAMES[@]}"
          echo "  ‚Ä¢ Release tag: $RELEASE_TAG"
          echo "  ‚Ä¢ Timestamp: $TIMESTAMP"
          echo ""
          echo "üìù Commits grouped by staging promotion:"
          printf "%s\n" "$GROUPED_MD"
          echo ""

          {
            echo "promotion_needed=true"
            echo "commit_count=$COMMIT_COUNT"
            echo "release_tag=$RELEASE_TAG"
            echo "timestamp=$TIMESTAMP"
            echo "existing_pr=${EXISTING_PR:-}"
          } >> "$GITHUB_OUTPUT"
          {
            echo "new_commits<<EOF"
            printf "%s" "$NEW_COMMITS"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "shas<<EOF"
            printf "%s\n" "${SHAS_IN_RANGE[@]}"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "groups<<EOF"
            printf "%s\n" "$GROUPS_LINES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "grouped_commits_md<<EOF"
            printf "%s\n" "$GROUPED_MD"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"
          {
            echo "promotion_prs_md<<EOF"
            printf "%s\n" "$PROMOTION_PRS_MD"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

  # Job 2: Create Production Promotion PR
  create-pr:
    name: Create Production PR
    runs-on: ubuntu-latest
    needs: commit-analysis
    if: needs.commit-analysis.outputs.promotion_needed == 'true' && inputs.create_pr
    outputs:
      pr_number: ${{ steps.create_pr.outputs.pr_number }}
      pr_url: ${{ steps.create_pr.outputs.pr_url }}

    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Ensure full fetch
        run: |
          git fetch --all --prune --tags
          # Also fetch the promoter branch if it exists
          git fetch origin production-promoter:origin-production-promoter || true

      - name: Detect existing PR for promoter branch
        id: check_existing
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          REPO="${GITHUB_REPOSITORY}"
          HEAD_BRANCH="production-promoter"
          EXISTING_NUMBER="$(gh pr list --base main --head "$HEAD_BRANCH" --state open --json number --jq '.[0].number' || true)"
          if [ -n "${EXISTING_NUMBER:-}" ] && [ "${EXISTING_NUMBER}" != "null" ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "pr_number=$EXISTING_NUMBER" >> "$GITHUB_OUTPUT"
            echo "pr_url=https://github.com/${REPO}/pull/${EXISTING_NUMBER}" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Build promoter branch with grouped squash commits
        id: build_promoter
        run: |
          set -euo pipefail

          PROMOTION_TAG="${{ needs.commit-analysis.outputs.release_tag }}"
          TEMP_BRANCH="production-promoter"
          EXISTING_PR="${{ steps.check_existing.outputs.exists }}"

          if [ "$EXISTING_PR" = "true" ]; then
            echo "üì¶ Updating existing promoter branch: $TEMP_BRANCH"
            git checkout -B "$TEMP_BRANCH" origin/production-promoter
          else
            echo "üì¶ Creating new promoter branch from main: $TEMP_BRANCH"
            git checkout -B "$TEMP_BRANCH" origin/main
          fi
          echo ""

          echo "üë§ Configuring git author for commits"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          echo "üîÄ Applying grouped cherry-picks as squash commits"
          echo ""

          # If updating existing PR, get list of existing squash commits
          if [ "$EXISTING_PR" = "true" ]; then
            echo "üìã Checking existing squash commits in promoter branch..."
            EXISTING_GROUPS=$(git log origin/main..HEAD --format=%s)
            echo "   Existing groups:"
            echo "$EXISTING_GROUPS" | sed 's/^/   - /'
            echo ""
          fi

          GROUPS_DATA='${{ needs.commit-analysis.outputs.groups }}'
          COMMITS_CREATED=0
          echo "$GROUPS_DATA" | while IFS='|' read -r group shas; do
            [ -z "$group" ] && continue
            [ -z "$shas" ] && continue
            echo "  ‚Ä¢ Group: $group"
            echo "    SHAs: $shas"

            # Check if this group already exists as a squash commit
            if [ "$EXISTING_PR" = "true" ]; then
              # For merge commits, check by commit message pattern
              if [ "$group" != "misc/ungrouped" ]; then
                group_title=$(git log -1 --format=%s "$group")
                if echo "$EXISTING_GROUPS" | grep -qF "$group_title"; then
                  echo "    ‚ÑπÔ∏è Group already exists in promoter branch, skipping"
                  echo ""
                  continue
                fi
              else
                if echo "$EXISTING_GROUPS" | grep -q "^misc/ungrouped$"; then
                  echo "    ‚ÑπÔ∏è Group already exists in promoter branch, skipping"
                  echo ""
                  continue
                fi
              fi
            fi
            echo ""

            # Sort commits chronologically within the group (oldest first)
            CHRONOLOGICAL_SHAS=""
            for sha in $shas; do
              commit_date=$(git log -1 --format=%ct "$sha" 2>/dev/null || echo "0")
              echo "${commit_date} ${sha}"
            done | sort -n | cut -d' ' -f2- > /tmp/chrono_shas.txt

            # Read the sorted SHAs back into the variable
            while read -r chrono_sha; do
              CHRONOLOGICAL_SHAS="$CHRONOLOGICAL_SHAS $chrono_sha"
            done < /tmp/chrono_shas.txt

            # Determine commit message for this group
            if [ "$group" = "misc/ungrouped" ]; then
              COMMIT_MSG="misc/ungrouped"
            else
              COMMIT_MSG=$(git log -1 --format=%s "$group")
            fi

            # Cherry-pick commits without committing (in chronological order)
            if git cherry-pick -n $CHRONOLOGICAL_SHAS; then
              # Check if there are any changes to commit
              if git diff --cached --quiet; then
                echo "    ‚ÑπÔ∏è No changes introduced (commits already in main), skipping"
              else
                git commit -m "$COMMIT_MSG"
                echo "‚úÖ Created squash commit for $COMMIT_MSG"
                echo ""
                COMMITS_CREATED=$((COMMITS_CREATED + 1))
              fi
            else
              echo "‚ö†Ô∏è Cherry-pick failed, aborting"
              git cherry-pick --abort || true
              exit 1
            fi
          done
          echo ""
          echo ""

          # Check if promoter branch has any new commits compared to main
          COMMITS_AHEAD=$(git rev-list --count origin/main..HEAD)
          if [ "$COMMITS_AHEAD" -eq 0 ]; then
            echo "‚ö†Ô∏è No new commits to promote (all commits already in main)"
            echo "‚ÑπÔ∏è Skipping promoter branch push"
            exit 0
          fi

          echo "üöÄ Pushing promoter branch ($COMMITS_AHEAD new commits)"
          git push -u origin "$TEMP_BRANCH" --force

          echo "temp_branch=$TEMP_BRANCH" >> "$GITHUB_OUTPUT"

      - name: Create or reuse PR from promoter branch to main
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          REPO="${GITHUB_REPOSITORY}"

          TITLE="Production Release: ${{ needs.commit-analysis.outputs.release_tag }}"

          # Prepare release notes section
          if [ -n "${{ inputs.release_notes }}" ]; then
            RELEASE_NOTES_SECTION="### üìí Release Notes
          ${{ inputs.release_notes }}"
          else
            RELEASE_NOTES_SECTION="### üìí Release Notes
          > **‚ö†Ô∏è No release notes provided**
          >
          > Please add release notes describing the changes in this release before merging."
          fi

          HEAD_BRANCH="production-promoter"

          echo "üßæ Building PR body file"
          BODY_FILE=body.md
          {
            echo "## üöÄ Production Deployment"
            echo ""
            echo "This PR promotes the staging environment to production."
            echo ""
            echo "### üìã Release Information"
            echo "- **Release Tag**: \`${{ needs.commit-analysis.outputs.release_tag }}\`"
            echo "- **Timestamp**: ${{ needs.commit-analysis.outputs.timestamp }}"
            echo "- **Commit Count**: ${{ needs.commit-analysis.outputs.commit_count }} commits"
            echo "- **Source**: \`staging\`"
            echo "- **Target**: \`main\`"
            echo "- **Triggered By**: @${{ github.actor }} via manual workflow dispatch"
            echo ""

            if [ -n "${{ needs.commit-analysis.outputs.promotion_prs_md }}" ]; then
              echo "### üîó Staging Promotion PRs"
              echo "${{ needs.commit-analysis.outputs.promotion_prs_md }}"
              echo ""
            fi

            echo "### üì¶ Features to be Deployed"
            echo "\`\`\`"
            echo "${{ needs.commit-analysis.outputs.grouped_commits_md }}" | sed 's/^####//' | sed 's/^PR:/  PR:/'
            echo "\`\`\`"
            echo ""

            echo "$RELEASE_NOTES_SECTION"
            echo ""

            echo "### üîÑ What Happens on Merge"
            echo "1. This PR branch contains one commit per staging promotion"
            echo "2. Merge with \"Create a merge commit\" or \"Rebase and merge\" to preserve grouped commits"
            echo "3. Tag \`${{ needs.commit-analysis.outputs.release_tag }}\` will be created (by post-merge workflow)"
            echo "4. Production deployment triggered"
            echo "5. Clean history: one commit per staging promotion"
            echo ""

            echo "### ‚úÖ Pre-deployment Checklist"
            echo "- [ ] Staging tests passed"
            echo "- [ ] Code review complete"
            echo "- [ ] DB migrations verified"
            echo "- [ ] Release notes reviewed"
            echo ""
            echo "---"
            echo "üîí Requires multiple approvals."
            echo ""
            echo "üë• Reviewers: @rahulcheryala @your-senior-dev"
          } > "$BODY_FILE"

          echo "üìù Ensuring PR base=main head=${HEAD_BRANCH}"

          echo "üîé Checking for existing open PR from promoter branch ‚Üí main..."
          EXISTING_NUMBER="$(gh pr list --base main --head "$HEAD_BRANCH" --state open --json number --jq '.[0].number' || true)"
          BODY_TEXT="$(cat "$BODY_FILE")"
          if [ -n "${EXISTING_NUMBER:-}" ] && [ "${EXISTING_NUMBER}" != "null" ]; then
            PR_NUMBER="$EXISTING_NUMBER"
            echo "üîÅ Reusing PR #$PR_NUMBER and updating title/body via API..."
            gh api -X PATCH "repos/${REPO}/pulls/${PR_NUMBER}" -f title="$TITLE" -f body="$BODY_TEXT" >/dev/null
          else
            echo "üÜï Creating PR base=main head=$HEAD_BRANCH via API..."
            PR_NUMBER="$(gh api -X POST "repos/${REPO}/pulls" \
              -f title="$TITLE" \
              -f head="$HEAD_BRANCH" \
              -f base="main" \
              -f body="$BODY_TEXT" \
              --jq .number)"
          fi

          PR_URL="$(gh api "repos/${REPO}/pulls/${PR_NUMBER}" --jq .html_url)"

          echo "üè∑Ô∏è Adding labels and requesting reviewers..."
          printf '{"labels":["production","deployment","release","auto-generated"]}\n' > labels.json
          gh api -X POST "repos/${REPO}/issues/${PR_NUMBER}/labels" --input labels.json >/dev/null || true
          printf '{"reviewers":["rahulcheryala","your-senior-dev"]}\n' > reviewers.json
          gh api -X POST "repos/${REPO}/pulls/${PR_NUMBER}/requested_reviewers" --input reviewers.json >/dev/null || true

          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "üîó PR Link: $PR_URL"

  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [commit-analysis, create-pr]
    if: always() && needs.commit-analysis.outputs.promotion_needed == 'true'
    steps:
      - name: Display workflow summary
        run: |
          echo ""
          echo "================================================"
          echo "üöÄ PRODUCTION PROMOTION WORKFLOW COMPLETED"
          echo "================================================"
          echo ""
          echo "‚úÖ Analysis complete"
          if [ "${{ needs.create-pr.result }}" = "success" ]; then
            echo "‚úÖ PR created/updated"
          else
            echo "‚ö†Ô∏è PR not created (skipped or failed)"
          fi
          echo ""
          echo "üìã Release Details:"
          echo "  ‚Ä¢ Release Tag: ${{ needs.commit-analysis.outputs.release_tag }}"
          echo "  ‚Ä¢ Timestamp: ${{ needs.commit-analysis.outputs.timestamp }}"
          echo "  ‚Ä¢ Commit Count: ${{ needs.commit-analysis.outputs.commit_count }}"
          echo "  ‚Ä¢ PR Number: ${{ needs.create-pr.outputs.pr_number }}"
          echo ""
          echo "üîó PR Link: ${{ needs.create-pr.outputs.pr_url }}"
          echo "‚ö†Ô∏è Reminder: Merging deploys to PRODUCTION."
          echo ""
