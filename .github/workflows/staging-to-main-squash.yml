name: Staging to Main with Final Squash

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

jobs:
  final-squash-and-merge:
    runs-on: ubuntu-latest
    if: github.base_ref == 'main' && github.head_ref == 'staging'

    steps:
      - name: Checkout staging branch
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze staging commits for final squash
        id: analyze_staging_commits
        run: |
          # Get commits that are in staging but not in main
          COMMITS_TO_FINAL_SQUASH=$(git log main..staging --oneline --no-merges)

          if [ -z "$COMMITS_TO_FINAL_SQUASH" ]; then
            echo "No commits to squash"
            exit 0
          fi

          # Count the number of commits to be squashed
          COMMIT_COUNT=$(echo "$COMMITS_TO_FINAL_SQUASH" | wc -l)

          # Generate release message with timestamp
          TIMESTAMP=$(date +'%Y-%m-%d %H:%M:%S UTC')
          RELEASE_TAG="release-$(date +'%Y%m%d-%H%M%S')"

          echo "Commits to be squashed into single release commit:"
          echo "$COMMITS_TO_FINAL_SQUASH"
          echo ""
          echo "Commit count: $COMMIT_COUNT"
          echo "Release tag: $RELEASE_TAG"

          # Create summary for the PR
          echo "final_squash_summary<<EOF" >> $GITHUB_OUTPUT
          echo "## 🚀 Final Release Squashing Plan" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**$COMMIT_COUNT commits** will be squashed into a single release commit:" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Release Information:" >> $GITHUB_OUTPUT
          echo "- **Release Tag**: \`$RELEASE_TAG\`" >> $GITHUB_OUTPUT
          echo "- **Timestamp**: $TIMESTAMP" >> $GITHUB_OUTPUT
          echo "- **Commit Count**: $COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Commits to be Squashed:" >> $GITHUB_OUTPUT
          echo '```' >> $GITHUB_OUTPUT
          echo "$COMMITS_TO_FINAL_SQUASH" >> $GITHUB_OUTPUT
          echo '```' >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Final Commit Message:" >> $GITHUB_OUTPUT
          echo "\`release: Production deployment $TIMESTAMP ($RELEASE_TAG)\`" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "⚠️ **Note**: This will create a clean production history with a single commit per release for easy rollbacks." >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT

      - name: Create final squashed commit
        if: steps.analyze_staging_commits.outputs.final_squash_summary != ''
        run: |
          echo "🚀 Creating final squashed commit for production release..."

          # Create a temporary branch for the final squashed commit
          git checkout -b temp-final-squash main

          # Create the final release commit message
          FINAL_COMMIT_MSG="release: Production deployment ${{ steps.analyze_staging_commits.outputs.timestamp }} (${{ steps.analyze_staging_commits.outputs.release_tag }})"

          # Simulate final squashing by creating a single commit
          echo "Creating final release commit: $FINAL_COMMIT_MSG"
          git commit --allow-empty -m "$FINAL_COMMIT_MSG"

          # Create and push the release tag
          git tag ${{ steps.analyze_staging_commits.outputs.release_tag }}
          git push origin ${{ steps.analyze_staging_commits.outputs.release_tag }}

          # Push the squashed branch
          git push origin temp-final-squash

          echo "✅ Final squashed commit created on temp-final-squash branch"
          echo "📋 Release tag created: ${{ steps.analyze_staging_commits.outputs.release_tag }}"

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Final Release Squashing Plan')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: `${{ steps.analyze_staging_commits.outputs.final_squash_summary }}`
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `${{ steps.analyze_staging_commits.outputs.final_squash_summary }}`
              });
            }
