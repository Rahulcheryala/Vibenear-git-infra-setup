name: Staging to Main with Final Squash

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

jobs:
  # Job 1: Setup and Analysis
  analyze-commits:
    runs-on: ubuntu-latest
    if: github.base_ref == 'main' && github.head_ref == 'staging'
    outputs:
      has_commits: ${{ steps.analyze.outputs.has_commits }}
      commit_count: ${{ steps.analyze.outputs.commit_count }}
      release_tag: ${{ steps.analyze.outputs.release_tag }}
      timestamp: ${{ steps.analyze.outputs.timestamp }}
      commits_list: ${{ steps.analyze.outputs.commits_list }}
      final_squash_summary: ${{ steps.analyze.outputs.final_squash_summary }}

    steps:
      - name: Checkout staging and main branches
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch main branch
        run: |
          echo "üì• Fetching main branch for comparison..."
          git fetch origin main:main
          echo "‚úÖ Main branch fetched successfully"

      - name: Analyze staging commits for final squash
        id: analyze
        run: |
          echo "üîç Analyzing commits in staging branch that are not in main..."

          # Get commits that are in staging but not in main
          COMMITS_TO_FINAL_SQUASH=$(git log main..staging --oneline --no-merges)

          if [ -z "$COMMITS_TO_FINAL_SQUASH" ]; then
            echo "‚úÖ No new commits found in staging branch"
            echo "üìã Staging and main branches are in sync"
            echo "has_commits=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          # Count the number of commits to be squashed
          COMMIT_COUNT=$(echo "$COMMITS_TO_FINAL_SQUASH" | wc -l)

          # Generate release message with timestamp
          TIMESTAMP=$(date +'%d/%m/%Y %H:%M:%S UTC')
          RELEASE_TAG="release_$(date +'%d-%m-%Y_%H.%M.%S')"

          echo "üìä Analysis Results:"
          echo "  ‚Ä¢ Commits to be squashed: $COMMIT_COUNT"
          echo "  ‚Ä¢ Release tag: $RELEASE_TAG"
          echo "  ‚Ä¢ Timestamp: $TIMESTAMP"
          echo ""
          echo "üìù Commits to be squashed into single release commit:"
          echo "$COMMITS_TO_FINAL_SQUASH"
          echo ""

          # Set outputs
          echo "has_commits=true" >> $GITHUB_OUTPUT
          echo "commit_count=$COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT

          echo "commits_list<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS_TO_FINAL_SQUASH" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Create summary for the PR
          echo "final_squash_summary<<EOF" >> $GITHUB_OUTPUT
          echo "## üöÄ Final Release Squashing Plan" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**$COMMIT_COUNT commits** will be squashed into a single release commit:" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Release Information:" >> $GITHUB_OUTPUT
          echo "- **Release Tag**: \`$RELEASE_TAG\`" >> $GITHUB_OUTPUT
          echo "- **Timestamp**: $TIMESTAMP" >> $GITHUB_OUTPUT
          echo "- **Commit Count**: $COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Commits to be Squashed:" >> $GITHUB_OUTPUT
          echo '```' >> $GITHUB_OUTPUT
          echo "$COMMITS_TO_FINAL_SQUASH" >> $GITHUB_OUTPUT
          echo '```' >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Final Commit Message:" >> $GITHUB_OUTPUT
          echo "\`release: Production deployment $TIMESTAMP ($RELEASE_TAG)\`" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "‚ö†Ô∏è **Note**: GitHub's built-in squash merge will create a clean production history with a single commit per release for easy rollbacks." >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  # Job 2: Create Release Tag
  create-release-tag:
    runs-on: ubuntu-latest
    needs: analyze-commits
    if: needs.analyze-commits.outputs.has_commits == 'true'

    steps:
      - name: Checkout staging branch
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push release tag
        env:
          RELEASE_TAG: ${{ needs.analyze-commits.outputs.release_tag }}
        run: |
          echo "üöÄ Preparing release information for production deployment..."
          echo "üìã Release tag: $RELEASE_TAG"
          echo ""

          echo "üè∑Ô∏è Creating and pushing release tag..."
          # Create and push the release tag
          git tag "$RELEASE_TAG"
          git push origin "$RELEASE_TAG"

          echo "‚úÖ Release tag created and pushed successfully: $RELEASE_TAG"
          echo "üìã GitHub's built-in squash merge will handle commit squashing when PR is merged"
          echo "üîÑ Production deployment will trigger automatically after merge"

  # Job 3: Comment on PR
  comment-on-pr:
    runs-on: ubuntu-latest
    needs: analyze-commits
    if: needs.analyze-commits.outputs.has_commits == 'true'

    steps:
      - name: Post release analysis comment
        uses: actions/github-script@v7
        env:
          FINAL_SQUASH_SUMMARY: ${{ needs.analyze-commits.outputs.final_squash_summary }}
        with:
          script: |
            const summary = process.env.FINAL_SQUASH_SUMMARY;

            // Get existing comments on the PR
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            // Find existing bot comment about release squashing
            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Final Release Squashing Plan')
            );

            if (botComment) {
              console.log('üîÑ Updating existing bot comment...');
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: summary
              });
              console.log('‚úÖ Bot comment updated successfully');
            } else {
              console.log('üìù Creating new bot comment...');
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: summary
              });
              console.log('‚úÖ Bot comment created successfully');
            }

  # Job 4: Workflow Summary
  workflow-summary:
    runs-on: ubuntu-latest
    needs: [analyze-commits, create-release-tag, comment-on-pr]
    if: always() && needs.analyze-commits.outputs.has_commits == 'true'

    steps:
      - name: Display workflow summary
        run: |
          echo ""
          echo "================================================"
          echo "üöÄ STAGING TO MAIN RELEASE ANALYSIS COMPLETED"
          echo "================================================"
          echo ""
          echo "‚úÖ Analysis: Commits analyzed successfully"
          echo "‚úÖ Tagging: Release tag created and pushed"
          echo "‚úÖ Comment: PR comment posted with release plan"
          echo ""
          echo "üìã Next Steps:"
          echo "  1. Review the PR comment for release details"
          echo "  2. Approve and merge the PR when ready"
          echo "  3. GitHub will automatically squash commits on merge"
          echo "  4. Production deployment will trigger automatically"
          echo ""
          echo "üè∑Ô∏è Release Tag: ${{ needs.analyze-commits.outputs.release_tag }}"
          echo "‚è∞ Timestamp: ${{ needs.analyze-commits.outputs.timestamp }}"
          echo "üìä Commit Count: ${{ needs.analyze-commits.outputs.commit_count }}"
          echo ""
