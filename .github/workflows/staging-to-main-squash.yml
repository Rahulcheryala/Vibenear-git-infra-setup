name: Staging to Main with Final Squash

on:
  pull_request:
    branches: [main]
    types: [opened, synchronize, reopened]

jobs:
  final-squash-and-merge:
    runs-on: ubuntu-latest
    if: github.base_ref == 'main' && github.head_ref == 'staging'

    steps:
      - name: Checkout staging and main branches
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Fetch main branch
        run: git fetch origin main:main

      - name: Analyze staging commits for final squash
        id: analyze_staging_commits
        run: |
          # Get commits that are in staging but not in main
          COMMITS_TO_FINAL_SQUASH=$(git log main..staging --oneline --no-merges)

          if [ -z "$COMMITS_TO_FINAL_SQUASH" ]; then
            echo "No commits to squash"
            exit 0
          fi

          # Count the number of commits to be squashed
          COMMIT_COUNT=$(echo "$COMMITS_TO_FINAL_SQUASH" | wc -l)

          # Generate release message with timestamp
          TIMESTAMP=$(date +'%d/%m/%Y %H:%M:%S UTC')
          RELEASE_TAG="release-$(date +'%d-%m-%Y_%H.%M.%S')"

          echo "Commits to be squashed into single release commit:"
          echo "$COMMITS_TO_FINAL_SQUASH"
          echo ""
          echo "Commit count: $COMMIT_COUNT"
          echo "Release tag: $RELEASE_TAG"

          # Create summary for the PR
          echo "final_squash_summary<<EOF" >> $GITHUB_OUTPUT
          echo "## ðŸš€ Final Release Squashing Plan" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "**$COMMIT_COUNT commits** will be squashed into a single release commit:" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Release Information:" >> $GITHUB_OUTPUT
          echo "- **Release Tag**: \`$RELEASE_TAG\`" >> $GITHUB_OUTPUT
          echo "- **Timestamp**: $TIMESTAMP" >> $GITHUB_OUTPUT
          echo "- **Commit Count**: $COMMIT_COUNT" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Commits to be Squashed:" >> $GITHUB_OUTPUT
          echo '```' >> $GITHUB_OUTPUT
          echo "$COMMITS_TO_FINAL_SQUASH" >> $GITHUB_OUTPUT
          echo '```' >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Final Commit Message:" >> $GITHUB_OUTPUT
          echo "\`release: Production deployment $TIMESTAMP ($RELEASE_TAG)\`" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "âš ï¸ **Note**: GitHub's built-in squash merge will create a clean production history with a single commit per release for easy rollbacks." >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "release_tag=$RELEASE_TAG" >> $GITHUB_OUTPUT
          echo "timestamp=$TIMESTAMP" >> $GITHUB_OUTPUT

      - name: Prepare release information
        if: steps.analyze_staging_commits.outputs.final_squash_summary != ''
        run: |
          echo "ðŸš€ Preparing release information for production deployment..."

          # Create and push the release tag
          git tag ${{ steps.analyze_staging_commits.outputs.release_tag }}
          git push origin ${{ steps.analyze_staging_commits.outputs.release_tag }}

          echo "âœ… Release tag created: ${{ steps.analyze_staging_commits.outputs.release_tag }}"
          echo "ðŸ“‹ GitHub's built-in squash will handle commit squashing on merge"

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('Final Release Squashing Plan')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: `${{ steps.analyze_staging_commits.outputs.final_squash_summary }}`
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `${{ steps.analyze_staging_commits.outputs.final_squash_summary }}`
              });
            }
